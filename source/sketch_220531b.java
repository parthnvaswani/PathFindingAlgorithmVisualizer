/* autogenerated by Processing revision 1283 on 2022-06-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class sketch_220531b extends PApplet {



ControlP5 cp5;
Button b1;

int square = 30, scl = 20;
int sizeWH = square * scl;
int controlsSize = 150;
Cell[][]graph = new Cell[square][square];
ArrayList<Cell> closelist = new ArrayList<Cell>();
ArrayList<Cell> openlist = new ArrayList<Cell>();
ArrayList<Cell> path = new ArrayList<Cell>();
Cell start, end;
Cell dfstemp;
boolean finished = false;
boolean playing = false;
boolean generate=false;
String locked = "";
int speed=1;
String []l={"A*","bfs","dfs"};
String algorithm="A*";

 public void settings() {
    size(sizeWH,sizeWH + controlsSize);
}

 public void setup() {
    setupControls();
    for (int i = 0;i < square;i++) {
        for (int j = 0;j < square;j++) {
            graph[i][j] = new Cell(i * scl,j * scl,i,j);
        }
    }
    frameRate(30);
    start = graph[0][0];
    end = graph[square - 1][square - 1];
    start.wall = end.wall = false;
    openlist.add(start);
    dfstemp=start;
}

 public void draw() {
    background(255);
    textSize(20);
    fill(0);
    text("Speed", 140, height - 90);
    text("Algorithm", 310, height - 90);
    text("Press space for generating maze!", 150, height - 130);
    fill(255);
    rect(480,height-140,100,130,28);
    for (int i = 0;i < square;i++) {
        for (int j = 0;j < square;j++) {
            graph[i][j].setColor(white);
        }
    }
    for (int index = 0; index < closelist.size(); index++) {
        closelist.get(index).setColor(red);
    }
    for (int index = 0; index < openlist.size(); index++) {
        openlist.get(index).setColor(blue);
    }
    for (int index = 0; index < path.size(); index++) {
        path.get(index).setColor(green);
    }
    start.setColor(yellow);
    end.setColor(cyan);
    if(mazeTemp!=null)
      mazeTemp.setColor(green);
    for (int i = 0;i < graph.length;i++) {
        for (int j = 0;j < graph[i].length;j++) {
            graph[i][j].show();
        }
    }
    if (playing && !finished &&  openlist.size() > 0 && frameCount%(speed-31)==0 && !generate) {
      if(algorithm=="A*")
        Astar();
      else if(algorithm=="bfs")
        bfs();
      else if(algorithm=="dfs")
        dfs();
    }
    if (mouseX > 0 &&  mouseX < width &&  mouseY > 0 &&  mouseY < height - controlsSize) {
        int i = floor(mouseX / scl);
        int j = floor(mouseY / scl);
        Cell t=graph[i][j];
        fill(0);
        text(String.format("f: %.02f\ng: %.02f\nh: %.02f",t.f,t.g,t.h), 490, height - 100);
    }
    if(generate && frameCount%(speed-31)==0 && playing && closelist.size()==0)
       getmaze();
}

 public void setupControls(){
    cp5 = new ControlP5(this);
    cp5.addButton("clearButt").setCaptionLabel("Clear").setPosition(20,height - 70).setSize(100,40);
    b1=cp5.addButton("playButt").setCaptionLabel("Play").setPosition(20,height - 120).setSize(100,40);
    cp5.addSlider("slider")
       .setPosition(140,height - 83)
       .setSize(150,20)
       .setRange(1,30)
       .setValue(speed);
    cp5.addScrollableList("dropdown")
     .setPosition(310, height-83)
     .setSize(150, 100)
     .setBarHeight(20)
     .setItemHeight(20)
     .addItems(l);
}

 public void clearGrid() {
    for (int i = 0;i < square;i++) {
        for (int j = 0;j < square;j++) {
            graph[i][j] = new Cell(i * scl,j * scl,i,j);
        }
    }
    closelist.clear();
    openlist.clear();
    path.clear();
    finished = false;
    start = graph[0][0];
    end = graph[graph.length - 1][graph[0].length - 1];
    start.wall = false;
    end.wall = false;
    openlist.add(start);
    dfstemp=start;
    generate=false;
    playing=false;
    b1.setCaptionLabel("Play");
}

 public void reset() {
    closelist.clear();
    openlist.clear();
    path.clear();
    finished = false;
    openlist.add(start);
    dfstemp=start;
}
 public void Astar() {
    Cell q = openlist.get(0);
    int index = 0;
    for (int i = openlist.size() - 1;i > 0;i--) {
        if (q.f > openlist.get(i).f) {
            q = openlist.get(i);
            index = i;
        }
    }
    
    if (q ==  end) {
        finished = true;
        return;
    }
    
    openlist.remove(index);
    
    ArrayList<Cell> neighbors = getNeighbors(q);
    for (int i = 0;i < neighbors.size();i++) {
        Cell neighbor = neighbors.get(i);
        if (!closelist.contains(neighbor) && !neighbor.wall) {
            float tempG = q.g + neighbor.heuristic(q);
            
            boolean newPath = false;
            if (openlist.contains(neighbor)) {
                if (tempG < neighbor.g) {
                    neighbor.g = tempG;
                    newPath = true;
                }
            } else {
                neighbor.g = tempG;
                openlist.add(neighbor);
                newPath = true;
            }
            
            if (newPath) {
                neighbor.h = neighbor.heuristic(end);
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.previous = q;
            }
        }
    }
    closelist.add(q);
    path.clear();
    Cell temp = q;
    path.add(temp);
    while(temp.previous!= null) {
        path.add(temp.previous);
        temp = temp.previous;
    }
}

 public ArrayList<Cell> getNeighbors(Cell q) {
    ArrayList<Cell>result = new ArrayList<Cell>();
    int i = q.i,j = q.j;
    if (i > 0) {
        result.add(graph[i - 1][j]);
    }
    if (j > 0) {
        result.add(graph[i][j - 1]);
    }
    if (i < graph.length - 1) {
        result.add(graph[i + 1][j]);
    }
    if (j < graph[0].length - 1) {
        result.add(graph[i][j + 1]);
    }
    if (j < graph[0].length - 1 &&  i < graph.length - 1) {
        result.add(graph[i + 1][j + 1]);
    }
    if (j > 0 &&  i > 0) {
        result.add(graph[i - 1][j - 1]);
    }
    if (j < graph[0].length - 1 &&  i > 0) {
        result.add(graph[i - 1][j + 1]);
    }
    if (i < graph.length - 1 &&  j > 0) {
        result.add(graph[i + 1][j - 1]);
    }
    return result;
}
class Cell{
    int i,j,x,y;
    float g,h,f;
    boolean wall;
    int colour;
    Cell previous;
    
    Cell() {
        this(0,0,0,0);      
    }
    Cell(int x,int y,int i,int j) {
        this.i = i;
        this.j = j;
        this.x = x;
        this.y = y;
        f = 0;
        g = 0;
        h = 0;
        colour = white;
        wall = false;
    }
     public void setColor(int colour) {
        this.colour = colour;
    }
     public void show() {
        if (this.wall) {
            fill(0);
        } else{
            fill(this.colour);
        }
        rect(this.x,this.y,scl,scl);
    }
     public float heuristic(Cell e) {
        return dist(this.x,this.y,e.x,e.y);
    }
}
Cell mazeTemp;
 public void generateMaze(){
  for (int i = 0;i < square;i++) {
    for (int j = 0;j < square;j++) {
        graph[i][j].wall=true;
    }
  }
  start.wall=false;
  mazeTemp=start;
  //visited.clear();
  generate=true;
}

 public void getmaze(){
    Cell neighbor=getRandNeighbor(mazeTemp);
    if(neighbor!=null){
      neighbor.previous=mazeTemp;
      mazeTemp=neighbor;
      mazeTemp.wall=false;
    }
    else{
      if(mazeTemp.previous==null){
        generate=false;
        end.wall=false;
      }
      mazeTemp=mazeTemp.previous;
    }
}

 public Cell getRandNeighbor(Cell q) {
    ArrayList<Cell>result = new ArrayList<Cell>();
    int i = q.i,j = q.j;
    if (i > 0 && graph[i - 1][j].wall && checkWalls(graph[i - 1][j])) {
        result.add(graph[i - 1][j]);
    }
    if (j < graph[0].length - 1 && graph[i][j + 1].wall && checkWalls(graph[i][j + 1])) {
        result.add(graph[i][j + 1]);
    }
    if (i < graph.length - 1 && graph[i + 1][j].wall && checkWalls(graph[i + 1][j])) {
        result.add(graph[i + 1][j]);
    }
    if (j > 0 && graph[i][j - 1].wall && checkWalls(graph[i][j - 1])) {
        result.add(graph[i][j - 1]);
    }
    if(result.size()==0)
      return null;
    return result.get(PApplet.parseInt(random(result.size())));
}

 public boolean checkWalls(Cell c){
  ArrayList<Cell> neighbors=getNeighborsDfs(c);
  int walls=0;
  for(int i=neighbors.size()-1;i>=0;i--){
    if(neighbors.get(i).wall)
      walls++;
  }
  return neighbors.size()-1==walls;
}
 public void clearButt() {
  clearGrid();
}

 public void playButt(){
  if(!playing)b1.setCaptionLabel("Pause");
  else b1.setCaptionLabel("Play");
  playing=!playing;
}

 public void slider(int s) {
  speed=s;
}

 public void dropdown(int n) {
  algorithm = cp5.get(ScrollableList.class, "dropdown").getItem(n).get("text").toString();
  reset();
}

 public void mousePressed() {
  if (mouseX > 0 &&  mouseX < width &&  mouseY > 0 &&  mouseY < height - controlsSize && !playing && closelist.size()==0) {
      int i = floor(mouseX / scl);
      int j = floor(mouseY / scl);
      
      if (graph[i][j] ==  start || graph[i][j] ==  end) {
          if (graph[i][j] ==  start)
              locked = "start";
          else
              locked = "end";
          return;
      }
      if (graph[i][j].wall)graph[i][j].wall = false;
      else graph[i][j].wall = true;
  }
}

 public void mouseDragged() {
  if(mouseX > 0 &&  mouseX < width &&  mouseY > 0 &&  mouseY < height - controlsSize)
    if (locked == "start") {
        start = graph[floor(mouseX / scl)][floor(mouseY / scl)];
        openlist.clear();
        openlist.add(start);
        dfstemp=start;
    } else if (locked == "end") {
        end = graph[floor(mouseX / scl)][floor(mouseY / scl)];
    }
}

 public void mouseReleased() {
    if(locked=="start")
      start.wall=false;
    else if(locked=="end")
      end.wall=false;
    locked = "";
}

 public void keyPressed(){
  if(key==' ' && !playing && closelist.size()==0){
    generate=true;
    generateMaze();
  }
}
 public void bfs(){
  int arrSize=openlist.size();
  for(int j=0;j<arrSize;j++){
    Cell c=openlist.get(j);
    closelist.add(c);
    if(c==end){
      finished=true;
      path.clear();
      Cell temp=end;
      path.add(temp);
      while(temp.previous!= null) {
          path.add(temp.previous);
          temp = temp.previous;
      }
    }
    ArrayList<Cell> neighbors=getNeighborsDfs(c);
    for(int i=neighbors.size()-1;i>=0;i--){
      Cell t=neighbors.get(i);
      if(!t.wall && !openlist.contains(t) && !closelist.contains(t)){
        t.previous=c;
        openlist.add(t);
      }
    }
  }
  for(int i=0;i<arrSize;i++){
    openlist.remove(0);
  }
}
int white= color(255,255,255);
int red = color(255,0,0);
int blue= color(0,0,255);
int green= color(0,255,0);
int yellow= color(255,255,0);
int cyan= color(0,255,255);
 public void dfs(){
  closelist.add(dfstemp);
  ArrayList<Cell> neighbors=getNeighborsDfs(dfstemp);
  boolean newPath=false;
  for(int i=neighbors.size()-1;i>=0;i--){
    Cell t=neighbors.get(i);
    if(!t.wall && !closelist.contains(t)){
      t.previous=dfstemp;
      dfstemp=t;
      newPath=true;
      break;
    }
  }
  if(dfstemp==end)
    finished=true;
  if(!newPath && dfstemp.previous!=null)
    dfstemp=dfstemp.previous;
  path.clear();
  Cell temp=dfstemp;
  path.add(temp);
  while(temp.previous!= null) {
      path.add(temp.previous);
      temp = temp.previous;
  }
}

 public ArrayList<Cell> getNeighborsDfs(Cell q) {
    ArrayList<Cell>result = new ArrayList<Cell>();
    int i = q.i,j = q.j;
    if (i > 0) {
        result.add(graph[i - 1][j]);
    }
    if (j < graph[0].length - 1) {
        result.add(graph[i][j + 1]);
    }
    if (i < graph.length - 1) {
        result.add(graph[i + 1][j]);
    }
    if (j > 0) {
        result.add(graph[i][j - 1]);
    }
    return result;
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "sketch_220531b" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
